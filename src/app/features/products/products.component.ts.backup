import { Component } from '@angular/core';
import {
  FormsModule,
  ReactiveFormsModule,
  FormBuilder,
  FormGroup,
  Validators,
} from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { CommonModule } from '@angular/common';
import { environment } from '../../../environment';
import { PaginationComponent } from '../../shared/pagination/pagination.component';
import { ProductService } from '../../services/product.service';
import { AuthService, User } from '../../services/auth.service';
import { CategoryService } from '../../services/category.service';
import { firstValueFrom } from 'rxjs';

@Component({
  selector: 'app-products',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    PaginationComponent,
  ],
  templateUrl: './products.component.html',
  styleUrl: './products.component.scss',
})
export class ProductsComponent {
  products: any[] = [];
  categories: any[] = [];
  subcategories: any[] = [];
  openAddCategoryPopup: boolean = false;
  popupImageUrl: string | null = null;
  openCreateModal = false;
  searchTerm: String = '';
  productForm!: FormGroup;
  categoryForm!: FormGroup;
  currentPage = 1;
  itemsPerPage = 10;
  totalItems = 0;
  totalPages = 0;
  isSubmitting = false;

  // Removed complex inline create inputs for simplicity

  // preserve original images on edit
  private editingOriginalImageUrls: string[] = [];

  // UI messages
  successMessage: string | null = null;
  errorMessage: string | null = null;


  // UI State
  showAdvancedOptions = false;

  // File upload state
  selectedImages: File[] = [];
  previewUrls: string[] = [];

  constructor(
    private http: HttpClient,
    private fb: FormBuilder,
    private productService: ProductService,
    private authService: AuthService,
    private categoryApi: CategoryService,
  ) {}

  private setSuccess(msg: string) {
    this.successMessage = msg;
    this.errorMessage = null;
    setTimeout(() => {
      if (this.successMessage === msg) this.successMessage = null;
    }, 3000);
  }
  private setError(msg: string) {
    this.errorMessage = msg;
    this.successMessage = null;
  }

  // Remove client-side pagination since we're using server-side pagination
  // The products array already contains the current page's products from the API

  ngOnInit() {
    this.productForm = this.fb.group({
      categoryId: [''],
      name: ['', Validators.required],
      description: [''],
      price: ['', Validators.required],
      stock: ['1', Validators.min(1)],
      isActive: [true],

      // Additional fields for complete payload
      sku: [''],
      brand: [''],
      gender: [''],
      material: [''],
      occasion: [''],
      sizes: [''],
      color: [''], // Changed from 'colors'
      tags: [''],
      imageUrls: [''], // Field for image URLs
    });

    this.categoryForm = this.fb.group({
      name: [''],
      slug: [''],
      iconUrl: [''],
      displayOrder: [0],
      isActive: [true],
      subCategoryName: [''],
    });

    // Simplified form - no subcategory handling needed

    this.getProducts();
    this.getCategories();
  }

  private getMerchantId(): string | null {
    const user: User | (User & { _id?: string }) | null =
      this.authService.getCurrentUser() as any;
    return (user as any)?._id || (user as any)?.id || null;
  }

  private generateUniqueSku(): string {
    const timestamp = Date.now().toString();
    const random = Math.floor(Math.random() * 1000)
      .toString()
      .padStart(3, '0');
    return `SKU-${timestamp}-${random}`;
  }

  getProducts() {
    const merchantId = this.getMerchantId();
    if (!merchantId) return;

    console.log('Fetching products with:', {
      merchantId,
      currentPage: this.currentPage,
      itemsPerPage: this.itemsPerPage,
      searchTerm: this.searchTerm,
    });

    this.productService
      .getProducts(
        merchantId,
        this.currentPage,
        this.itemsPerPage,
        this.searchTerm.toString()
      )
      .subscribe({
        next: (res) => {
          console.log('=== FULL API RESPONSE ===');
          console.log('Raw response:', res);
          console.log('Response type:', typeof res);
          console.log('Response keys:', Object.keys(res || {}));

          // Try different possible response structures
          this.products =
            res?.products ||
            res?.product ||
            res?.data?.products ||
            res?.data?.product ||
            [];
          console.log('Products array:', this.products);
          console.log('Products count:', this.products.length);
          console.log('First product:', this.products[0]);

          // Handle pagination data - try different possible structures
          const pagination =
            res?.pagination ||
            res?.meta ||
            res?.data?.pagination ||
            res?.data?.meta;
          console.log('Pagination object:', pagination);

          if (pagination) {
            this.currentPage = pagination.page || pagination.currentPage || 1;
            this.totalItems =
              pagination.total ||
              pagination.totalItems ||
              pagination.count ||
              0;
            this.totalPages =
              pagination.pages ||
              pagination.totalPages ||
              Math.ceil(this.totalItems / this.itemsPerPage) ||
              1;
            this.itemsPerPage =
              pagination.limit ||
              pagination.itemsPerPage ||
              pagination.perPage ||
              10;

            console.log('=== PAGINATION PROCESSED ===');
            console.log('Current page:', this.currentPage);
            console.log('Total items:', this.totalItems);
            console.log('Total pages:', this.totalPages);
            console.log('Items per page:', this.itemsPerPage);
            console.log('============================');
          } else {
            console.log('❌ No pagination data found in response');
            console.log('Available response keys:', Object.keys(res || {}));
          }

          // Force update pagination component by triggering change detection
          setTimeout(() => {
            console.log('=== FINAL PAGINATION VALUES ===');
            console.log('totalItems:', this.totalItems);
            console.log('totalPages:', this.totalPages);
            console.log('currentPage:', this.currentPage);
            console.log('itemsPerPage:', this.itemsPerPage);
            console.log('===============================');
          }, 100);
        },
        error: (err) => console.error('Fetch failed:', err),
      });
  }

  getCategories() {
    this.categoryApi
      .getCategories()
      .subscribe((res) => (this.categories = res.categories || []));
  }

  getSubcategories() {
    this.categoryApi
      .getSubcategories()
      .subscribe((res) => (this.subcategories = res.subcategory || []));
  }

  onPageChange(page: number) {
    this.currentPage = page;
    this.getProducts();
  }

  onSearch() {
    this.currentPage = 1; // Reset to first page when searching
    this.getProducts();
  }

  private loadSubcategoriesForCategory(id: string) {
    this.categoryApi.getSubcategoriesByCategoryId(id).subscribe({
      next: (res) => {
        this.subcategories = res?.subcategories || [];
      },
      error: (err) =>
        console.error('Failed to load subcategories for category', err),
    });
  }

  openCreatePopup() {
    this.productForm.reset({
      stock: 1, // Default stock to 1
      isActive: true,
      sku: this.generateUniqueSku(), // Generate unique SKU
    });
    this.showAdvancedOptions = false;
    this.selectedImages = [];
    this.previewUrls = [];
    this.openCreateModal = true;
  }

  openEditPopup(product: any) {
    this.openCreateModal = true;
    this.productForm.patchValue({
      categoryId: product.categoryId || product.category?._id || '',
      name: product.name || '',
      description: product.description || '',
      price: product.price || 0,
      stock: product.stock ?? 0,
      isActive: !!product.isActive,
      sku: product.sku || '',
      brand: product.brand || '',
      gender: product.gender || '',
      material: product.material || '',
      occasion: product.occasion || '',
      sizes: Array.isArray(product.sizes) ? product.sizes.join(', ') : '',
      color: Array.isArray(product.color) ? product.color.join(', ') : '',
      tags: Array.isArray(product.tags) ? product.tags.join(', ') : '',
      imageUrls: Array.isArray(product.imageUrls)
        ? product.imageUrls.join(', ')
        : '',
    });
    (this.productForm as any)._editingId = product._id || product.id;
    this.editingOriginalImageUrls = Array.isArray(product.imageUrls)
      ? product.imageUrls.slice()
      : [];
    this.selectedImages = [];
    this.previewUrls = [];
  }

  closeCreatePopup() {
    this.openCreateModal = false;
    (this.productForm as any)._editingId = undefined;
  }

  deleteProduct(product: any) {
    const merchantId = this.getMerchantId();
    if (!merchantId) return;
    if (!confirm('Delete this product?')) return;
    this.productService.deleteProduct(product._id || product.id).subscribe({
      next: () => {
        this.getProducts();
      },
      error: (err) => console.error('Delete failed', err),
    });
  }

  // Removed filesToImagesPayload - now using ImageKit upload instead

  async submitProduct() {
    if (this.productForm.invalid) {
      this.setError('Please fill in all required fields.');
      return;
    }
    this.isSubmitting = true;

    const formValue = this.productForm.value;
    const categoryId: string | null = formValue.categoryId || null;
    const merchantId = this.getMerchantId();

    try {
      if (!merchantId) {
        this.isSubmitting = false;
        this.setError('No merchant logged in');
        return;
      }

      const editingId = (this.productForm as any)._editingId as
        | string
        | undefined;

      if (editingId) {
        this.isSubmitting = false;
        this.setError('Product update with images not implemented yet');
        return;
      }

      // Build FormData with files and all product data
      const formData = new FormData();

      // Add all text fields
      formData.append('name', formValue.name);
      formData.append('price', String(Number(formValue.price)));
      formData.append('stock', String(Number(formValue.stock)));
      formData.append('categoryId', categoryId || '');
      formData.append('storeId', merchantId);
      formData.append('isActive', String(!!formValue.isActive));

      // Add optional text fields
      if (formValue.sku) formData.append('sku', formValue.sku);
      if (formValue.description)
        formData.append('description', formValue.description);
      if (formValue.brand) formData.append('brand', formValue.brand);
      if (formValue.gender) formData.append('gender', formValue.gender);
      if (formValue.material) formData.append('material', formValue.material);
      if (formValue.occasion) formData.append('occasion', formValue.occasion);

      // Handle arrays - convert to JSON strings
      if (formValue.sizes) {
        const sizesArray = String(formValue.sizes)
          .split(',')
          .map((s: string) => s.trim())
          .filter((s) => s.length > 0);
        if (sizesArray.length > 0) {
          formData.append('sizes', JSON.stringify(sizesArray));
        }
      }

      if (formValue.color) {
        const colorsArray = String(formValue.color)
          .split(',')
          .map((s: string) => s.trim())
          .filter((s) => s.length > 0);
        if (colorsArray.length > 0) {
          formData.append('color', JSON.stringify(colorsArray));
        }
      }

      if (formValue.tags) {
        const tagsArray = String(formValue.tags)
          .split(',')
          .map((s: string) => s.trim())
          .filter((s) => s.length > 0);
        if (tagsArray.length > 0) {
          formData.append('tags', JSON.stringify(tagsArray));
        }
      }

      // Add image files under 'imageUrls' key (backend expects this field name)
      this.selectedImages.forEach((file) => {
        formData.append('imageUrls', file);
      });

      // Add any manually entered image URLs as strings
      if (formValue.imageUrls) {
        const manualUrls = String(formValue.imageUrls)
          .split(',')
          .map((url: string) => url.trim())
          .filter((url: string) => url.length > 0);
        manualUrls.forEach((url) => {
          formData.append('imageUrls', url);
        });
      }

      // Debug logging
      console.log('=== Creating product with FormData ===');
      console.log(
        'Endpoint:',
        `${environment.apiUrl}/api/merchant/${merchantId}/products`
      );
      console.log(
        'Selected images:',
        this.selectedImages.map((f) => f.name)
      );
      console.log('Form fields added to FormData');
      console.log('=====================================');

      // Send FormData to product API (browser sets multipart/form-data automatically)
      const response = await firstValueFrom(
        this.http.post<any>(
          `${environment.apiUrl}/api/merchant/${merchantId}/products`,
          formData
          // No Content-Type header - let browser set multipart/form-data
        )
      );

      this.isSubmitting = false;
      this.setSuccess('Product created successfully');
      this.getProducts();
      this.closeCreatePopup();
    } catch (err: any) {
      this.isSubmitting = false;
      const apiMsg = err?.error?.message || 'Error saving product';
      this.setError(apiMsg);
      console.error('Save failed:', err);
    }
  }

  saveStock(product: any) {
    const merchantId = this.getMerchantId();
    if (!merchantId) return;
    const stock = Number(product.stock) || 0;
    this.productService
      .updateStock(merchantId, product._id || product.id, stock)
      .subscribe({
        next: () => {
          this.setSuccess('Stock updated');
        },
        error: (err) => {
          this.setError('Update stock failed');
          console.error('Update stock failed', err);
        },
      });
  }

  saveActive(product: any) {
    const merchantId = this.getMerchantId();
    if (!merchantId) return;
    this.productService
      .updateProduct(product._id || product.id, {
        isActive: !!product.isActive,
      })
      .subscribe({
        next: () => {
          this.setSuccess('Status updated');
        },
        error: (err) => {
          this.setError('Update status failed');
          console.error('Update active failed', err);
        },
      });
  }

  searchProducts() {
    this.onSearch(); // Use the unified search method
  }

  openImagePopup(url: string | null | undefined) {
    if (!url) return;
    this.popupImageUrl = url;
  }

  closeImagePopup() {
    this.popupImageUrl = null;
  }

  onImageSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    console.log('File input triggered:', input);
    console.log('Files selected:', input.files);

    if (input.files && input.files.length > 0) {
      this.processFiles(input.files);
    } else {
      console.log('No files selected');
      this.setError('No files selected. Please try again.');
    }
  }

  /**
   * Analyze product image with AI and suggest form values
   */

  /**
   * Apply AI suggestions to the form (excludes price and stock)
   */
  applyAiSuggestions(): void {
    return;
    const updates: any = {};

    // Apply suggestions to all relevant form fields EXCEPT price and stock
    if (data.productName) {
      updates.name = data.productName;
    }
    if (data.description) {
      updates.description = data.description;
    }
    if (data.brand) {
      updates.brand = data.brand;
    }
    if (data.color) {
      updates.color = data.color;
    }
    if (data.size) {
      updates.sizes = data.size;
    }
    if (data.material) {
      updates.material = data.material;
    }

    // Try to find matching category
    if (data.category) {
      const matchingCategory = this.categories.find(
        (cat) =>
          cat.name.toLowerCase().includes(data.category!.toLowerCase()) ||
          data.category!.toLowerCase().includes(cat.name.toLowerCase())
      );
      if (matchingCategory) {
        updates.categoryId = matchingCategory._id;
      }
    }

    // Infer gender from product name or category
    if (data.productName || data.category) {
      const text = `${data.productName || ''} ${
        data.category || ''
      }`.toLowerCase();
      if (
        text.includes('men') ||
        text.includes('male') ||
        text.includes('boy')
      ) {
        updates.gender = 'Men';
      } else if (
        text.includes('women') ||
        text.includes('female') ||
        text.includes('girl') ||
        text.includes('lady')
      ) {
        updates.gender = 'Women';
      } else {
        updates.gender = 'Unisex';
      }
    }

    // Infer occasion from product name/description
    if (data.productName || data.description) {
      const text = `${data.productName || ''} ${
        data.description || ''
      }`.toLowerCase();
      if (
        text.includes('formal') ||
        text.includes('dress') ||
        text.includes('suit')
      ) {
        updates.occasion = 'Formal';
      } else if (
        text.includes('casual') ||
        text.includes('everyday') ||
        text.includes('relaxed')
      ) {
        updates.occasion = 'Casual';
      } else if (
        text.includes('sport') ||
        text.includes('gym') ||
        text.includes('athletic')
      ) {
        updates.occasion = 'Sports';
      } else if (
        text.includes('party') ||
        text.includes('evening') ||
        text.includes('night')
      ) {
        updates.occasion = 'Party';
      }
    }

    // Generate smart tags based on all available data
    const tags: string[] = [];
    if (data.category) tags.push(data.category.toLowerCase());
    if (data.material) tags.push(data.material.toLowerCase());
    if (updates.gender) tags.push(updates.gender.toLowerCase());
    if (updates.occasion) tags.push(updates.occasion.toLowerCase());

    // Add seasonal tags
    const text = `${data.productName || ''} ${
      data.description || ''
    }`.toLowerCase();
    if (
      text.includes('summer') ||
      text.includes('light') ||
      text.includes('breathable')
    ) {
      tags.push('summer');
    }
    if (
      text.includes('winter') ||
      text.includes('warm') ||
      text.includes('thick')
    ) {
      tags.push('winter');
    }
    if (
      text.includes('trendy') ||
      text.includes('fashionable') ||
      text.includes('stylish')
    ) {
      tags.push('trendy');
    }

    if (tags.length > 0) {
      updates.tags = [...new Set(tags)].join(', '); // Remove duplicates
    }

    // Apply all updates at once
    this.productForm.patchValue(updates);

    this.showAiSuggestions = false;
    this.setSuccess(
      '✅ AI suggestions applied to form! (Price and stock preserved)'
    );
  }

  /**
   * Dismiss AI suggestions
   */
  dismissAiSuggestions(): void {
    // AI functionality removed
    return;
  }

  /**
   * Manually trigger AI analysis (when auto-analysis is disabled)
   */
  analyzeProductImageManually(): void {
    // AI functionality removed
    return;
  }

  /**
   * Analyze with Gemini specifically from URL
   */
  async analyzeWithGemini(): Promise<void> {
    // AI functionality removed
    return;
  }

  /**
   * Triggers AI analysis from the image URL input field
   */
  async analyzeImageUrls(): Promise<void> {
    // AI functionality removed
    return;
  }

  /**
   * Use fallback analysis when OpenAI is not available
   */
  async useFallbackAnalysis(): Promise<void> {
    // AI functionality removed
    return;
  }

  removeImage(file: File) {
    this.selectedImages = this.selectedImages.filter(
      (f) =>
        f.name !== file.name || f.size !== file.size || f.type !== file.type
    );
    this.previewUrls = this.previewUrls.slice(0, this.selectedImages.length);
  }

  // Drag and Drop functionality
  onDragOver(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
  }

  onDragLeave(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
  }

  onDrop(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();

    const files = event.dataTransfer?.files;
    if (files && files.length > 0) {
      console.log('Files dropped:', files);
      this.processFiles(files);
    }
  }

  private processFiles(fileList: FileList) {
    const imageFiles = Array.from(fileList).filter((file) => {
      const isImage = file.type.startsWith('image/');
      const isValidSize = file.size <= 10 * 1024 * 1024; // 10MB limit

      if (!isImage) {
        console.warn('Skipping non-image file:', file.name);
      }
      if (!isValidSize) {
        console.warn('Skipping oversized file:', file.name, 'Size:', file.size);
      }

      return isImage && isValidSize;
    });

    if (imageFiles.length === 0) {
      this.setError(
        'No valid image files found. Please select PNG, JPG, JPEG, GIF, or WebP files under 10MB.'
      );
      return;
    }

    if (imageFiles.length !== fileList.length) {
      this.setError(
        `${
          fileList.length - imageFiles.length
        } file(s) were skipped (not images or too large).`
      );
    }

    this.selectedImages = imageFiles;
    console.log('Processed images:', this.selectedImages);

    // Create preview URLs
    this.previewUrls = this.selectedImages.map((file) => {
      console.log('Creating preview for:', file.name, file.type, file.size);
      return URL.createObjectURL(file);
    });

    this.setSuccess(`${imageFiles.length} image(s) selected successfully!`);

    // AI functionality removed
  }
}
