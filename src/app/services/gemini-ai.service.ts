import { Injectable } from '@angular/core';
import { environment } from '../../environment';
import { ProductInfo } from './ai-form-fill.service';

@Injectable({
  providedIn: 'root',
})
export class GeminiAiService {
  private geminiApiKey = environment.geminiApiKey;
  private geminiApiUrl =
    'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

  constructor() {}

  /**
   * Analyze product image using Google Gemini Vision
   * @param imageFile - The uploaded image file
   * @returns Promise with extracted product information
   */
  async analyzeProductImage(
    imageFile: File
  ): Promise<{ success: boolean; data?: ProductInfo; error?: string }> {
    try {
      if (
        !this.geminiApiKey ||
        this.geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE'
      ) {
        throw new Error('Gemini API key not configured');
      }

      // Convert image to base64
      const base64Image = await this.fileToBase64(imageFile);
      const mimeType = imageFile.type;

      const prompt = `You are an expert product analyst. Analyze this product image and extract comprehensive information.

Return ONLY a valid JSON object with these fields (use null for missing information):
{
  "productName": "string (clear, descriptive product name)",
  "description": "string (detailed 2-3 sentence description highlighting key features)",
  "category": "string (specific category: Electronics, Clothing, Shoes, Accessories, Food, Books, Home, Beauty, Sports, etc.)",
  "price": "number (extract price if visible on labels, tags, or packaging)",
  "brand": "string (brand name if visible on product, logo, or packaging)",
  "color": "string (primary color or dominant colors, comma-separated)",
  "size": "string (size information: clothing sizes S/M/L, shoe sizes, dimensions, etc.)",
  "material": "string (material composition if identifiable: cotton, leather, plastic, metal, etc.)",
  "weight": "string (weight if visible on packaging or labels)",
  "dimensions": "string (dimensions if visible or can be estimated from packaging)"
}

Analyze all visible text, labels, packaging, and visual elements. Be specific and accurate.`;

      const payload = {
        contents: [
          {
            parts: [
              {
                text: prompt,
              },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Image,
                },
              },
            ],
          },
        ],
        generationConfig: {
          temperature: 0.1,
          topK: 32,
          topP: 1,
          maxOutputTokens: 1024,
        },
      };

      const response = await fetch(
        `${this.geminiApiUrl}?key=${this.geminiApiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.error?.message || response.statusText;

        // Handle specific error types
        if (response.status === 400) {
          throw new Error('Invalid request to Gemini API. Check image format.');
        } else if (response.status === 403) {
          throw new Error('Gemini API key invalid or quota exceeded.');
        } else {
          throw new Error(`Gemini API error: ${errorMessage}`);
        }
      }

      const result = await response.json();
      const candidates = result.candidates;

      if (!candidates || candidates.length === 0) {
        throw new Error('No response generated by Gemini');
      }

      const content = candidates[0]?.content?.parts?.[0]?.text;
      if (!content) {
        throw new Error('No content received from Gemini');
      }

      // Extract JSON from the response (sometimes Gemini includes extra text)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No valid JSON found in Gemini response');
      }

      // Parse the JSON response
      const productInfo: ProductInfo = JSON.parse(jsonMatch[0]);

      return {
        success: true,
        data: productInfo,
      };
    } catch (error) {
      console.error('Error analyzing product image with Gemini:', error);
      return {
        success: false,
        error:
          error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Convert File to base64 string
   */
  private fileToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result as string;
        // Remove the data:image/jpeg;base64, prefix
        const base64 = result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  /**
   * Validate image file
   */
  validateImageFile(file: File): { valid: boolean; error?: string } {
    const maxSize = 4 * 1024 * 1024; // 4MB for Gemini
    const allowedTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];

    if (!allowedTypes.includes(file.type)) {
      return {
        valid: false,
        error: 'Please upload a valid image file (JPEG, PNG, WebP)',
      };
    }

    if (file.size > maxSize) {
      return {
        valid: false,
        error: 'Image file size should be less than 4MB for Gemini',
      };
    }

    return { valid: true };
  }
}
